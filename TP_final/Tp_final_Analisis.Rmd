---
title: 'TP Final Laboratorio de Datos'
subtitle: 'Analisis de talles de zapato'
author: 'Sol Calloni, Guido Freire, Micaela Hirsch'
output:
  html_document:
    df_print: paged
---

# Analisis exploratorio (EDA)

Veamos y estudiemos un poco la información que tenemos.

```{r}
datos <- read.csv('chicos.csv')
algunas_filas <- sample(1:nrow(datos), 10)
datos[algunas_filas,]
```

Se observa que las unidades del dataset no son las mas intuitivas. Convertimos las medidas a explorar a formatos mas amigables: WEIGHT (kg), AGE (y) y medidas (cm).

```{r}
obligatorios <- c('WEIGHT', 'STATURE', 'SEX', 'RACE', 'AGE.IN.MONTHS')
escogidos <- c('ELBOW.HAND.LENGTH', 'HEAD.BREADTH', 'FOOT.LENGTH', 'FOOT.BREADTH', 'SPHYRION.HEIGHT', 'KNEE.HEIGHT')

datos$WEIGHT <- datos$WEIGHT / 10
datos$AGE <- datos$AGE.IN.MONTHS / 12
datos$STATURE <- datos$STATURE / 10

datos[, escogidos] <- datos[, escogidos] / 10

head(datos[, c(obligatorios, escogidos)])
```

Convertimos las unidades de todas las variables a cm (estaba en mm). Convertimos los 0 a NA y quitamos las personas con edades NA.

```{r}
datos[datos == 0] <- NA
datos <- datos[!is.na(datos$AGE),]
```

```{r}
summary(datos[, escogidos])

boxplot(datos[, escogidos], las = 2, outline = FALSE)
```

Los valores son coherentes. Veamos cuantos faltantes hay:

```{r}
apply(datos[, escogidos], 2, function(x) sum(is.na(x)))
```

Ademas, para no tener que recordar qué significa cada uno de los números que se encuentra en las columnas SEX y RACE, decidimos reemplazar cada uno por la clasificación que le corresponde.

```{r}
datos$SEX <- factor(datos$SEX, labels = c('masculino', 'femenino'))
datos$RACE <- factor(datos$RACE, labels = c('white', 'black', 'oriental', 'am. indian', 'mixed'))
```

Estudiemos un poco la variable de estatura, cómo cambia en relación al sexo y la raza.

```{r}
layout(t(c(1,2,2)))

boxplot(STATURE ~ SEX, data = datos, ylim = range(datos$STATURE, na.rm = TRUE))

boxplot(STATURE ~ RACE, data = datos, ylim = range(datos$STATURE, na.rm = TRUE))
text(1:length(levels(datos$RACE)), range(datos$STATURE, na.rm = TRUE)[2] + 0.2, paste('n =', table(datos$RACE)))
```

En el gráfico de la izquierda podemos observar que la mayor parte de las personas, sin importar el sexo, tienen una altura que va entre 1.2 y 1.6 metros. No solo eso, si no que la mediana es practicamente igual, 1.4 metros.

Por otro lado, en el gráfico de la derecha estudiamos la altura en relación a las razas que contiene el dataset. Es importante considerar lo que nos marcan los 'n =', nos indican la cantidad de personas que pertenecientes a aquellas categorías.

Analicemos las relaciones entre peso, estatura y edad con la ayuda de los siguientes gráficos.

```{r}
normalizar <- function(vec){
  return((vec - min(vec)) / (max(vec) - min(vec)))
}

masomenos <- function(x, y, tol) {
  return(y <= x + tol & y >= x - tol)
}

STATURE_norm <- normalizar(datos[!is.na(datos$STATURE), 'STATURE'])
AGE_norm <- normalizar(datos[datos$AGE, 'AGE'])

plot(WEIGHT ~ AGE, datos, col = rgb(STATURE_norm, 0, 1 - STATURE_norm), pch = 4, xlab = 'AGE (y)', ylab = 'WEIGHT (kg)')
legend('topleft', legend = c('mas alto', 'menos alto'), col = c('red', 'blue'), pch = 4)

plot(WEIGHT ~ STATURE, datos,
     col = ifelse(masomenos(datos$AGE, median(datos$AGE), 0.5), 'green', rgb(AGE_norm, 0, 1 - AGE_norm)),
     pch = 4, xlab = 'STATURE (m)', ylab = 'WEIGHT (kg)')
legend('topleft', legend = c('mas edad', 'menos edad'), col = c('red', 'blue'), pch = 4)
```

Los valores cercanos a la mediana se encuentran de color verde. Podríamos ver si se corresponde con la pubertad. Tener en cuenta que es EEUU.

```{r}
coplot(STATURE ~ AGE | RACE + SEX, datos, rows = 1)
```

Lo mas llamativo es la diferencia en cantidades de datos segun raza y sexo.

Veamos los gráficos anteriores en función del sexo.

```{r}
col_sex <- c('green', 'magenta')
names(col_sex) <- levels(datos$SEX)

plot(WEIGHT ~ AGE, datos, col = col_sex[datos$SEX], pch = 4, xlab = 'AGE (y)', ylab = 'WEIGHT (kg)')
legend('topleft', legend = levels(datos$SEX), col = col_sex, pch = 4)
```

En el caso del peso, se puede observar que crece en función de la edad de manera similar en ambos sexos hasta llegar a los 15 aproximadamente. A partir de allí, se nota un comportamiento distinto entre ambos sexos, el peso de los hombres creciendo más rápidamente que el de las mujeres.

```{r}
plot(WEIGHT ~ STATURE, datos,
     col = col_sex[datos$SEX],
     pch = 4, xlab = 'STATURE (m)', ylab = 'WEIGHT (kg)', log='y')
legend('topleft', legend = levels(datos$SEX), col = col_sex, pch = 4)
```

El comportamiento de la altura según la edad es similar para ambos sexos, sin embargo a partir del 1.6 aproximadamente se 'estancan' los datos de mujeres, mientras que los hombres continúan en aumento.

Notemos que el eje y esta en escala logarítmica, por lo tanto si quisieramos plantear un modelo, no podría ser uno lineal.

# Modelado

Comecemos armando un modelo que prediga el peso en función del sexo y la edad.

```{r}
modelo_edadf <- lm(WEIGHT~AGE, data=datos[datos$SEX=='femenino', ])
modelo_edadf
```

```{r}
modelo_edadm <- lm(WEIGHT~AGE, data=datos[datos$SEX=='masculino', ])
modelo_edadm
```

Notemos que los coeficientes cambian dependendiendo del sexo con el cual estemos trabajando. Según el modelo, los niños tienen `r round(modelo_edadm$coefficients[2] - modelo_edadf$coefficients[2], 2)` más peso por año que las niñas.

```{r}
modelo_edadf2 <- lm(WEIGHT~poly(AGE, 2), data=datos[datos$SEX=='femenino', ])
modelo_edadf2
```

```{r}
modelo_edadm2 <- lm(WEIGHT~poly(AGE, 2), data=datos[datos$SEX=='masculino', ])
modelo_edadm2
```

Visualicemos los modelos!

(!) ARREGLAR COLORES

```{r}
plot(WEIGHT ~ AGE, datos, col = col_sex[datos$SEX], pch = 4, xlab = 'AGE (y)', ylab = 'WEIGHT (kg)')
legend('topleft', legend = levels(datos$SEX), col = col_sex, pch = 4)
abline(modelo_edadf, col = 'magenta4', lwd=2)
abline(modelo_edadm, col = 'dark green', lwd=2)
lines(1:20, predict(modelo_edadf2, newdata = data.frame('AGE' = 1:20)), col = 'magenta4', lwd=2, lty=2)
lines(1:20, predict(modelo_edadm2, newdata = data.frame('AGE' = 1:20)), col = 'dark green', lwd=2, lty=2)

```

Comparamos modelos lineales y cuadráticos, en el caso de las mujeres no se ve diferencia mientras que en el de los hombres sí.

```{r}
# install.packages('rgl')
library('rgl')
plot3d(WEIGHT~AGE+STATURE, data=datos, col = col_sex[datos$SEX])
rglwidget()
```

Gracias a este gráfico somos capaces de observar que llega un punto que en las mujeres se detiene el aumento de peso y estatura.

Hagamos esto mismo pero con las razas:

```{r}
col_raza <- rainbow(length(levels(datos$RACE)))
names(col_raza) <- levels(datos$RACE)
plot(STATURE~AGE, datos, col=col_raza[datos$RACE], pch=4)
legend('topleft', legend = levels(datos$RACE), col = col_raza, pch = 4)
```

Podemos observar que la amplia mayoria de la gente es blanca, no podemos observar comportamientos distintos.

Nos quedamos con los datos de las personas de categoría blanca y negra, ya que componen la mayor parte del dataset, del resto de las razas no tenemos suficiente información.

Armemos modelos:

```{r}
modelo_alturab <- lm(STATURE~AGE, data = datos[datos$RACE=='black',])
modelo_alturab
```

```{r}
modelo_alturaw <- lm(STATURE~AGE, data = datos[datos$RACE=='white',])
modelo_alturaw
```

(!) ARREGLAR COLORES

```{r}
plot(STATURE~AGE, datos, col=col_raza[datos[datos$RACE == 'black' | datos$RACE == 'white', ]$RACE])
abline(modelo_alturab, col='blue', lwd = 2)
abline(modelo_alturaw, col='green', lwd = 2)
```

No se puede apreciar una diferecia significativa entre ambos modelos. La poca diferencia puede estar sesgada por la cantidad de datos.

# Analisis de talles de zapato

Agreguemos una nueva columna donde se nos indique el talle de la persona. Nos vamos a guiar por los talles determinados por [adidas](https://www.adidas.com.ar/cual_es_mi_talle_adidas.html).

```{r}
talle <- function(longitud) {
  return(ceiling((longitud + 2*0.667) / 0.667 /0.5) * 0.5)
}

datos$TALLE <- talle(datos$FOOT.LENGTH)
head(datos$TALLE)
```

Exploremos un poco las relaciones

```{r}
plot3d(TALLE~ELBOW.HAND.LENGTH+AGE, datos, col= col_sex[datos$SEX])
#legend('topleft', legend = levels(datos_usados$SEX), col = col_sex, pch = 4)
rglwidget()
```

Super lineal :O

Además, podemos observar cómo hay un 'corte' para las mujeres (teniendo la misma edad, las mujeres llega un punto en el que dejan de crecer)

Con la edad crece el talle.

Estudiemos más a fondo el modelo que predice el talle en función del peso.

```{r}
modelo_w <- lm(TALLE~WEIGHT, datos)
plot(TALLE~WEIGHT, datos, log='x')
lines(1:100, predict(modelo_w, newdata = data.frame('WEIGHT' = 1:100)), col = 'red', lwd=2)
```

Se puede apreciar cierta relación entre las variables peso y talle. Observen que al cambiar la escala del eje x, en vez de una curva exponencial, se observa una recta.

Mejoraría al plantear un modelo exponencial.

Estudiemos el de edad y estatura

```{r}
modelo_as <- lm(TALLE~AGE+STATURE, datos)
plot3d(modelo_as, col= col_sex[datos[!is.na(datos$TALLE) & !is.na(datos$AGE) & !is.na(datos$STATURE), 'SEX']])
rglwidget()
```

Volvemos a observar el 'corte'.

Definimos algunas funciones para evaluacion de modelos. MAE y PMAE son metricas y crossval realiza validacion cruzada.

```{r}
MAE <- function(x, y) {
  validos <- which(!is.na(x) & !is.na(y))
  return(sum(abs(x[validos] - y[validos])) / length(x[validos]))
}

PMAE <- function(x, y) {
  validos <- which(!is.na(x) & !is.na(y))
  return(sum(abs(x[validos] - y[validos])) / sum(x[validos]))
}

crossval <- function(datos, formu, n_obs, fun_error, n_muestras = 1) {
  errores <- NULL
  for (i in 1:n_muestras) {
    samp_ev <- sample(1:nrow(datos), n_obs)
    modelo <- lm(formu, data = datos[-samp_ev,])
    error <- fun_error(predict(modelo, datos[samp_ev,]), datos[samp_ev, toString(formu[[2]])])
    errores <- c(errores, error)
  }
  return(list(errores = errores, promedio = mean(errores), varianza = var(errores), formula = formu, modelo = lm(formu, data = datos)))
}
```

Agregamos funciones para seleccion de parametros: sin_NAs devuelve indices de filas sin NAs en las columnas especificadas, comb_lineal prueba combinaciones de parametros para modelos lineales y realiza validacion cruzada en cada uno.

```{r}
sin_NAs <- function(datos, columnas){ #devuelve índices sin NAs
   return(which(apply(datos[columnas], 1, function (x) !any(is.na(x)))))
}

comb_lineal <- function(datos, independientes, dependiente, tamanio=length(independientes)) {
  errores <- NULL
  for (m in 1:tamanio) {
    validos <- sin_NAs(datos, c(dependiente, independientes))
    combinaciones <- combn(independientes, m)
    for (i in 1:ncol(combinaciones)) {
      val <- crossval(datos[validos,], as.formula(paste(dependiente, ' ~ ', paste(combinaciones[,i], collapse = ' + '))), 20, PMAE, 2)
      errores <- rbind(errores, data.frame(combinacion = paste(combinaciones[,i], collapse = ' + '),
                                    err_pred = val$promedio,
                                    err_ajus = PMAE(datos[validos, dependiente], predict(val$modelo)),
                                    varianza = val$varianza,
                                    num_variables = length(combinaciones[,i]) ))
    }
  }
  return(errores)
}
```

```{r}
boxplot(datos[, 'FOOT.LENGTH'], main='Medida de pie')
quantile(datos[, 'FOOT.LENGTH'], na.rm = TRUE)
```

```{r}
boxplot(datos[, 'TALLE'], main='Talle')
```

# Estudiemos algunos de los modelos.

Inicialmente cuando investigabamos como generar modelos, tomamos todas las columnas con menos del 20% de NAs. A partir de esto, utilizamos una funcion combinatoria para validar los modelos lineales posibles de HASTA 5 variables.

Hecho esto, elegimos esteticamente las que nos llamaron la atencion. En el .Rmd esta el codigo completo, por ahora importamos una computacion anterior de la funcion.

```{r, echo = FALSE, eval = FALSE}
cant_NA <- apply(datos, 2, function(x) sum(is.na(x)))
cant_NA

menos_20 <- names(cant_NA[cant_NA<(3900*20/100)])

menos_20 <- menos_20[!menos_20 %in% c('PERSON..', 'AGE.IN.YEARS', 'LOCATION', 'MEASUREMENT.DATE', 'MEASUREMENT.SET.TP', 'MEASURER.NUMBER', 'COMPUTER.NUMBER', 'TWIN', 'BIRTH.ORDER', 'MOTHERS.OCCUPATION', 'FATHERS.OCCUPATION', 'MOTHERS.EDUCATION', 'FATHERS.EDUCATION', 'YEARS.IN.COMMUNITY', 'TALLE', 'FOOT.LENGTH', 'FOOT.BREADTH')]
datos_talle <- datos[, c(menos_20, 'TALLE')]

errores_talle20 <- comb_lineal(datos_talle, menos_20, 'TALLE', 5)

errores_talle20$combinacion = as.factor(errores_talle20$combinacion)
par(mar = c(5,0,0,0) + 5)

plot.default(errores_talle20$combinacion, errores_talle20$err_pred, axes = FALSE, ylim = c(0, 0.5), col = 'green', xlab = '', ylab = 'PMAE', main = 'Errores por formula (linear)')
axis(side = 1, at = 1:length(errores_talle20$combinacion), labels = errores_talle20$combinacion, las = 2, cex.axis = 0.5)
axis(side=2, at=seq(0, 0.5, 0.1), labels = seq(0, 0.5, 0.1), cex.axis = 1)
points(errores_talle20$combinacion, errores_talle20$err_ajus, col = 'blue')
legend('topright', c('prediccion', 'ajuste'), col = c('green', 'blue'), pch = 1)
```

```{r}
errores_talle20 <- read.csv('errores_talle_20.csv')
errores_talle20 <- errores_talle20[,-1]
errores_talle20$err_pred <- round(errores_talle20$err_pred, 4)
head(errores_talle20)
```

Modelemos las variables que elegimos.

```{r}
modelo_elbow <- lm(TALLE ~ ELBOW.HAND.LENGTH, data = datos)

plot(TALLE ~ ELBOW.HAND.LENGTH, datos)
abline(modelo_elbow, col = 'red', lwd = 2)
```

Hay una relacion cercana entre el antebrazo + mano y el talle de zapato. Investiguemos que tan bueno es el modelo para cada talle observado:

Su PMAE por validacion cruzada es  `r errores_talle20[errores_talle20$combinacion == 'ELBOW.HAND.LENGTH', 'err_pred']`

Armemos un modelo poco prometedor para comparar contra el resto.

```{r}
modelo_head <- lm(TALLE ~ HEAD.BREADTH, data = datos)
```

El modelo tiene un PMAE por validacion cruzada de `r errores_talle20[errores_talle20$combinacion == 'HEAD.BREADTH', 'err_pred']`

Veamos lo que sucede cuando combinamos una variable que sabemos es buena (ELBOW.HAND.LENGTH) con una que es pesima (HEAD.BREADTH):

```{r}
modelo_hae <- lm(TALLE ~ HEAD.BREADTH + ELBOW.HAND.LENGTH, data = datos)

plot3d(modelo_hae)
rglwidget()
```

El PMAE por validacion cruzada de este modelo es `r errores_talle20[errores_talle20$combinacion == 'HEAD.BREADTH + ELBOW.HAND.LENGTH', 'err_pred']`; mayor que el de ELBOW.HAND.LENGTH.

A modo de puesta en comun, presentamos los graficos para cada modelo lado a lado:

```{r}
par(mfrow = c(1,3))

plot(predict(modelo_elbow) ~ TALLE, datos[!is.na(datos$TALLE) & !is.na(datos$ELBOW.HAND.LENGTH),],xlab = 'TALLE observado', ylab = 'TALLE predicho', ylim = c(20, 50), main = 'ELBOW.HAND.LENGTH')
abline(0, 1, col = 'red', lwd = 2)
plot(predict(modelo_head) ~ TALLE, datos[!is.na(datos$TALLE) & !is.na(datos$HEAD.BREADTH),],xlab = 'TALLE observado', ylab = 'TALLE predicho', ylim = c(20, 50), main = 'HEAD.BREADTH')
abline(0, 1, col = 'red', lwd = 2)
plot(predict(modelo_hae) ~ TALLE, datos[!is.na(datos$TALLE) & !is.na(datos$HEAD.BREADTH) & !is.na(datos$ELBOW.HAND.LENGTH),],xlab = 'TALLE observado', ylab = 'TALLE predicho', ylim = c(20, 50), main = 'HEAD.BREADTH + ELBOW.HAND.LENGTH')
abline(0, 1, col = 'red', lwd = 2)
```

En este grafico visualizamos lo observado y lo predicho. De ser perfecto el modelo, todos los puntos caerian sobre la recta roja (identidad). Observamos que estan dispersos, aunque bastante cerca de la identidad. Es decir que el modelo subestima y sobreestima en medidas parecidas.

En este caso el parametro ELBOW.HAND.LENGTH mejora el desempenio de HEAD.BREADTH. Sin embargo, la prediccion de ELBOW.HAND.LENGTH es aun mejor que la combinacion. Esto se refleja en las metricas discutidas, presentadas a continuacion:

```{r}
errores_talle20[errores_talle20$combinacion %in% c('ELBOW.HAND.LENGTH', 'HEAD.BREADTH', 'HEAD.BREADTH + ELBOW.HAND.LENGTH'), c('combinacion', 'err_pred')]
```


# ¿Hay una forma mejor de establecer un talle?

Para cada talle ver cuánto varía el ancho, trabajamos con varianza:

```{r}
boxplot(FOOT.BREADTH~TALLE, data = datos, outline=FALSE)
```

Veamos la distancia intercuartil y desviacion estandar maximas.

```{r}
max(aggregate(FOOT.BREADTH~TALLE, data = datos, sd)[[2]], na.rm = TRUE)
max(aggregate(FOOT.BREADTH~TALLE, data = datos, IQR)[[2]])
```

Las metricas no parecen indicar que el ancho de pie varie tanto segun el talle. En este aspecto el talle es un buen indicador.

```{r}
plot(FOOT.BREADTH ~ TALLE, data = datos, col = col_sex[datos$SEX])
```

De la desviacion estandar y la distancia intercuartil concluimos que FOOT.BREADTH esta estrechamente relacionado a TALLE. La relacion es mucho mas explicita con el grafico anterior.

Ademas, se sigue observando el corte de talle femenino.

Repetimos el tratamiento de FOOT.BREADTH con SPHYRION.HEIGHT (la altura del empeine).

El n es mucho mas reducido (`r length(sin_NAs(datos, c('FOOT.LENGTH', 'FOOT.BREADTH', 'SPHYRION.HEIGHT')))`)

```{r}
plot(SPHYRION.HEIGHT ~ TALLE, data = datos, col = col_sex[datos$SEX], xlim=c(18, 50))
```

```{r}
max(aggregate(SPHYRION.HEIGHT / 10~TALLE, data = datos, sd)[[2]], na.rm = TRUE)
max(aggregate(SPHYRION.HEIGHT / 10~TALLE, data = datos, IQR)[[2]])
```

Notemos que la distancia intercuartil es bastante elevada teniendo en cuenta que estamos hablando de calzado. El talle, que solo toma en cuenta la longitud del pie, omite medidas importantes como la altura del empeine.

```{r}
volle <- function(volumen) {
  return(ceiling(volumen/0.5) * 0.5)
}

datos_full = datos[!is.na(datos$TALLE) & !is.na(datos$SPHYRION.HEIGHT) & !is.na(datos$FOOT.LENGTH) & !is.na(datos$FOOT.BREADTH), c('TALLE', 'SPHYRION.HEIGHT', 'FOOT.BREADTH', 'FOOT.LENGTH')]
datos_full$VOLLE = volle(datos_full$FOOT.BREADTH * datos_full$FOOT.LENGTH * datos_full$SPHYRION.HEIGHT)
datos_full$TALLE = talle(datos_full$FOOT.LENGTH)

mod_volle = list(SPHYRION.HEIGHT = lm(SPHYRION.HEIGHT ~ poly(VOLLE, 3), datos_full), 
                 FOOT.LENGTH = lm(FOOT.LENGTH ~ poly(VOLLE, 3), datos_full),
                 FOOT.BREADTH = lm(FOOT.BREADTH ~ poly(VOLLE, 3), datos_full))

mod_talle = list(SPHYRION.HEIGHT = lm(SPHYRION.HEIGHT ~ poly(TALLE, 3), datos_full), 
                 FOOT.LENGTH = lm(FOOT.LENGTH ~ poly(TALLE, 3), datos_full),
                 FOOT.BREADTH = lm(FOOT.BREADTH ~ poly(TALLE, 3), datos_full))

par(mfrow = c(3,2))
plot(SPHYRION.HEIGHT ~ VOLLE, datos_full)
lines(500:2500, predict(mod_volle[['SPHYRION.HEIGHT']], newdata = data.frame(VOLLE = 500:2500)), col = "red")
plot(SPHYRION.HEIGHT ~ TALLE, datos_full)
lines(20:50, predict(mod_talle[['SPHYRION.HEIGHT']], newdata = data.frame(TALLE = 20:50)), col = "red")

plot(FOOT.LENGTH ~ VOLLE, datos_full)
lines(500:2500, predict(mod_volle[['FOOT.LENGTH']], newdata = data.frame(VOLLE = 500:2500)), col = "red")
plot(FOOT.LENGTH ~ TALLE, datos)
lines(20:50, predict(mod_talle[['FOOT.LENGTH']], newdata = data.frame(TALLE = 20:50)), col = "red")

plot(FOOT.BREADTH ~ VOLLE, datos_full)
lines(500:2500, predict(mod_volle[['FOOT.BREADTH']], newdata = data.frame(VOLLE = 500:2500)), col = "red")
plot(FOOT.BREADTH ~ TALLE, datos_full)
lines(20:50, predict(mod_talle[['FOOT.BREADTH']], newdata = data.frame(TALLE = 20:50)), col = "red")
```
